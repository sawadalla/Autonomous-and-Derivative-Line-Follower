#pragma config(Sensor, in1,    right,          sensorLineFollower)
#pragma config(Sensor, in2,    center,         sensorLineFollower)
#pragma config(Sensor, in3,    left,           sensorLineFollower)
#pragma config(Sensor, dgtl5,  OnOffButton,    sensorTouch)
#pragma config(Motor,  port2,           frontRight,    tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           frontLeft,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           Collector,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port5,           Dumper_right,  tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port8,           Dumper_left,   tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port6,           backRight,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port7,           backLeft,      tmotorServoContinuousRotation, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int nErrorValue;
int nLastError;
int nDerivative;
int nCycles = 0;

int nAdjustment;
int nLeftMotor;
int nRightMotor;

int nMaxSpeed = 38;
int nPFactor =  10; //10
int nDFactor =  95;//45


bool bMotorsDisabled  = true;
bool bClickInProgress = false;

int getLineErrorPosition()
{
	static int nLastPos = 0;
	int nPos = 0;
	int nNumbOfHits = 0;

	//GET THRESHOLD VALUES HERE
	const int kThreshold1 = 2400;
	const int kThreshold2 = 2600;
	const int kThreshold3 = 2800;

#define checkSensor(nSensor, nWeight)\
	if (SensorValue[nSensor]  > kThreshold1)\
	{\
		if (SensorValue[nSensor] > kThreshold3)\
		{nPos += 3 * nWeight; nNumbOfHits += 3;}\
		else if (SensorValue[nSensor] > kThreshold2)\
		{nPos += 2 * nWeight; nNumbOfHits += 2;}\
		else \
		{nPos += 1 * nWeight; nNumbOfHits += 1;}\
	}
	checkSensor(left,   -100);
	checkSensor(center,   0);
	checkSensor(right,  +100);

	switch (nNumbOfHits)
	{
	case 0:
		// Line was not detected. Use the last detected value
		return nLastPos;

	case 1:
		break;

	default:
		nPos /= nNumbOfHits;
		break;
	}
	nLastPos = nPos;      // Save the last detected position
	return nPos;
}

void processButton()
{
	if (bClickInProgress)
	{
		if (SensorValue[OnOffButton])
			bClickInProgress = false;
	}
	else
	{
		if (!SensorValue[OnOffButton])
		{
			bMotorsDisabled = !bMotorsDisabled;
			bClickInProgress = true;
		}
	}
}





task main()
{

	int buttonToggleState = 0;
	int buttonPressed = 0;

	while(true)
	{
	reset_again:
		allMotorsOff();

		// when Btn7U is activated
		if(vexRT(Btn7U) == 1 && vexRT(Btn7D) == 0 && vexRT(Btn7R) == 0)
		{
			while(true)
			{
				int X2 = 0, Y1 = 0, X1 = 0, threshold = 15;

				if(abs(vexRT[Ch3]) > threshold)
					Y1 = vexRT[Ch3];
				else
					Y1 = 0;
				if(abs(vexRT[Ch4]) > threshold)
					X1 = vexRT[Ch4];
				else
					X1 = 0;

				//  motor[frontRight] = Y1 - X2 - X1;
				//motor[backRight] =  Y1 - X2 + X1;
				//motor[frontLeft] = Y1 + X2 + X1;
				//motor[backLeft] =  Y1 + X2 - X1;

				motor[frontRight] = Y1 - X2 - X1;
				motor[backRight] =  -Y1 + X2 - X1;
				motor[frontLeft] =  Y1 + X2 + X1;
				motor[backLeft] =  -Y1 - X2 + X1;

				//////////Collector Motor//////////
				if(vexRT(Btn8R)==1)
				{
					if(!buttonPressed)
					{
						buttonToggleState = 1 - buttonToggleState;
						buttonPressed = 1;
					}
				}
				else
				{
					buttonPressed = 0;
				}

				if(buttonToggleState)
				{
					motor[Collector] = 127;
				}
				else
				{
					motor[Collector] = 0;
				}

				//////////Dumper Code//////////
				if(vexRT[Btn6D]==1)
				{
					motor[Dumper_left] = 30;
					motor[Dumper_right] = 30;
				}
				else
				{
					motor[Dumper_left] = 0;
					motor[Dumper_right] = 0;
				}

				if(vexRT[Btn5D] == 1)
				{
					motor[Dumper_left] = -30;
					motor[Dumper_right] = -30;
				}
				else
				{
					motor[Dumper_left] = 0;
					motor[Dumper_right] = 0;
				}

				// MOVE TO OTHER CHALLENGE
				if(vexRT(Btn7D) == 1 || vexRT(Btn7R) == 1)
				{
					goto reset_again;
				}
			}
		}

		// when Btn7D is activated
		if(vexRT(Btn7U) == 0 && vexRT(Btn7D) == 1 && vexRT(Btn7R) == 0)
		{
			wait1Msec(1000);
			//int thresholdline = 2000;      // we have to take a reading of the black tape
			while(true)
			{
				++nCycles;
				processButton();

				nErrorValue = getLineErrorPosition();
				nDerivative = nErrorValue - nLastError;
				nAdjustment = ((nErrorValue * nPFactor) + (nDerivative * nDFactor))/ 100;
				nLastError  = nErrorValue;

				if (nAdjustment > 0)
				{
					nLeftMotor  = nMaxSpeed + nAdjustment;
					nRightMotor = nMaxSpeed - 10 * nAdjustment / 2; //8
					if (nRightMotor < 0)
						nRightMotor = 0;
				}
				else
				{
					nLeftMotor  = nMaxSpeed + 10 * nAdjustment / 2;
					nRightMotor = nMaxSpeed - nAdjustment;
					if (nLeftMotor < 0)
						nLeftMotor = 0;
				}


				if (bMotorsDisabled)
				{
					motor[backLeft]  = 0;
					motor[backRight] = 0;
				}
				else
				{
					motor[backLeft]  = nLeftMotor;
					motor[backRight] = nRightMotor;
				}

				static int nLastVexSPIMsgCounts = 0;
				int nCurrVexSPIMsgCounts = 0;

				while (true)
				{
					nCurrVexSPIMsgCounts = nVexSPIMsgCounts;
					if (nCurrVexSPIMsgCounts != nLastVexSPIMsgCounts)
					{
						nLastVexSPIMsgCounts = nVexSPIMsgCounts;
						break;
					}
				}
				// MOVE TO OTHER CHALLENGE
				if(vexRT(Btn7U) == 1 || vexRT(Btn7R) == 1)
				{
					goto reset_again;
				}
			}
		}

		if(vexRT(Btn7U) == 0 && vexRT(Btn7D) == 0 && vexRT(Btn7R) == 1)
		{

			//go straight 3.2 seconds
			motor[Collector] = 127;
			motor[frontLeft]  = 20;
			motor[backLeft]  = -20;
			motor[frontRight] = 24;
			motor[backRight] = -24;
			wait1Msec(3200);

			//turn/swing right
			motor[Collector] = 127;
			motor[frontLeft]  = 30;
			motor[backLeft]  = 0;
			motor[frontRight] = 0;
			motor[backRight] = -50;
			wait1Msec(1700);

			motor[Collector] = 127;
			motor[frontLeft]  = 20;
			motor[backLeft]  = -20;
			motor[frontRight] = 23;
			motor[backRight] = -23;
			wait1Msec(3200);

			//turn/swing right
			motor[Collector] = 127;
			motor[frontLeft]  = 30;
			motor[backLeft]  = 0;
			motor[frontRight] = 0;
			motor[backRight] = -50;
			wait1Msec(1600);

			//go straight 1.8 seconds
			motor[Collector] = 127;
			motor[frontLeft]  = 20;
			motor[backLeft]  = -20;
			motor[frontRight] = 23;
			motor[backRight] = -23;
			wait1Msec(1800);

			//turn/swing right
			motor[Collector] = 127;
			motor[frontLeft]  = 30;
			motor[backLeft]  = 0;
			motor[frontRight] = 0;
			motor[backRight] = -50;
			wait1Msec(1500);

			//go straight 1.8 seconds
			motor[Collector] = 127;
			motor[frontLeft]  = 20;
			motor[backLeft]  = -20;
			motor[frontRight] = 23;
			motor[backRight] = -23;
			wait1Msec(1800);


			//turn/swing right
			motor[Collector] = 127;
			motor[frontLeft]  = 30;
			motor[backLeft]  = 0;
			motor[frontRight] = 0;
			motor[backRight] = -50;
			wait1Msec(1700);

			//go straight 2 seconds
			motor[Collector] = 127;
			motor[frontLeft]  = 20;
			motor[backLeft]  = -20;
			motor[frontRight] = 23;
			motor[backRight] = -23;
			wait1Msec(2000);

				//turn/swing right
			motor[Collector] = 127;
			motor[frontLeft]  = 30;
			motor[backLeft]  = 0;
			motor[frontRight] = 0;
			motor[backRight] = -50;
			wait1Msec(1700);

			// MOVE TO OTHER CHALLENGE
			if(vexRT(Btn7U) == 1 || vexRT(Btn7D) == 1)
			{
				goto reset_again;
			}
		}
		motor[frontLeft]  = 0;
		motor[backLeft]  = 0;
		motor[frontRight] = 0;
		motor[backRight] = 0;
		motor[Collector] = 0;
		motor[Dumper_left] = 0;
		motor[Dumper_right] = 0;

	}
}
